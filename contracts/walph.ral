Contract Walph(
    poolSize: U256,
    poolOwner: Address,
    poolFees: U256,
    tokenIdToHold: ByteVec,
    ticketPrice: U256,
    mut minTokenAmountToHold: U256,
    mut open: Bool,
    mut balance: U256,
    mut feesBalance: U256,
    mut numAttendees: U256,
    mut attendees: [Address;21],
    mut lastWinner: Address
){
    

    event TicketBought(from: Address, amount: U256)
    event PoolOpen()
    event PoolClose()
    event Destroy(from: Address)
    event NewMinTokenAmountToHold(newAmount: U256)
    event Winner(address: Address)

    enum ErrorCodes {
        PoolFull = 0
        PoolAlreadyClose = 1
        PoolAlreadyOpen = 2
        PoolClosed = 3
        InvalidCaller = 4
        NotEnoughToken = 5
        PoolNotFull = 6
        InvalidAmount = 7
    }


    fn random() -> (U256){
        assert!(numAttendees > 0, ErrorCodes.PoolNotFull)
        let seed = u256From32Byte!(blake2b!(toByteVec!(blockTarget!()) ++ toByteVec!(blockTimeStamp!())))
        emit Debug(`rnd is ${seed}`)
        return addModN!(0,seed, numAttendees) // Good to add numAttendees instead of zero. numAttendees is not accessible to the external caller.
    }

    @using(preapprovedAssets = true, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    fn distributePrize(lastAttendee: Address, amount: U256) -> (){
         checkCaller!(callerAddress!() == selfAddress!(), ErrorCodes.InvalidCaller)
         assert!(balance + amount >= poolSize, ErrorCodes.PoolNotFull) // Q: It seems in your current design, they should be equal?

        lastWinner = attendees[random()]
        
        // Q1: basis point is more common, i.e. poolFees / 10000: https://en.wikipedia.org/wiki/Basis_point
        // Q2: should the owner get `poolSize` * poolFees / N? The fee of the amount is not charged in `balance * poolFees/N`.
        let poolOwnerAmount = balance * poolFees/100
        let winnerAmount = balance - poolOwnerAmount
        balance = 0
        numAttendees = 0

        //transferTokenFromSelf!(poolOwner, ALPH, poolOwnerAmount)
        transferTokenFromSelf!(lastWinner, ALPH, winnerAmount)

        // the last attendee will be the one with the rest of ALPH to sent to the winner, it will be the one who send it in addition of the rest of the pool
        transferToken!(lastAttendee, lastWinner, ALPH, amount)

        emit Winner(lastWinner)

     }


    pub fn getPoolState() -> (Bool) {
        return open
    }

    pub fn getPoolSize() -> (U256) {
        return poolSize
    }

    pub fn getBalance() -> (U256){
        return balance
    }

    pub fn getTicketPrice() -> (U256){
        return ticketPrice
    }
    
    @using(preapprovedAssets = false, assetsInContract = true, updateFields = true)
    pub fn withdraw() -> () {
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)
        assert!(feesBalance > 0, ErrorCodes.PoolNotFull)

        // (poolFees/100) * 10**18 == poolFees * 10**16
        transferTokenFromSelf!(poolOwner, ALPH, feesBalance - 2* dustAmount!()) // to not hit LowerThanContractMinimalBalance
        feesBalance = 0

    }

    // Note that if there is 1 ticket left and there are 5 users trying to buy it, only 1 will get it, the other 4 will get a failed tx.
    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn buyTicket(amount: U256) -> (){
        let caller = callerAddress!()
        assert!(balance + amount <= poolSize, ErrorCodes.PoolFull)
        assert!(open, ErrorCodes.PoolClosed)
        assert!(addModN!(amount,0 , 10 ** 18) == 0, ErrorCodes.InvalidAmount)
        assert!(amount >= ticketPrice, ErrorCodes.InvalidAmount)
        if (minTokenAmountToHold > 0){
            assert!(tokenRemaining!(caller, tokenIdToHold) >= minTokenAmountToHold, ErrorCodes.NotEnoughToken)
        }
                
        let numberTicketsBought = amount / ticketPrice
        let mut numberPlaceCounter = 0

        // fill the array with the buyer address
        while (numberPlaceCounter < numberTicketsBought){
            attendees[numAttendees] = caller
            numAttendees = numAttendees + 1
            numberPlaceCounter = numberPlaceCounter + 1

        }

        emit TicketBought(caller, amount)

        // used to check if the amount added will close the pool
        let balanceCheck = balance + amount
        feesBalance = feesBalance + amount * poolFees/100
        // last person to complete the pool close it and start the draw
        if (balanceCheck >= poolSize){
            assert!(balanceCheck >= poolSize, ErrorCodes.PoolNotFull)
            
            // check if the number of attendees is full
            assert!(numAttendees == poolSize / ticketPrice, ErrorCodes.PoolNotFull)
            

            distributePrize{selfAddress!() -> ALPH: balance + dustAmount!(); caller -> ALPH: amount}(caller, amount)
       } else {
            balance = balance + amount
            transferTokenToSelf!(caller, ALPH, amount)
       }
    }

    // Note that the owner could close the pool even when it is not full, not a big deal though.
    @using(updateFields = true, checkExternalCaller = true)
    pub fn closePool() -> (){
        assert!(open, ErrorCodes.PoolAlreadyClose)
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        open = false

        emit PoolClose()
    }

    @using(updateFields = true, checkExternalCaller = true)
    pub fn openPool() -> (){
        assert!(!open, ErrorCodes.PoolAlreadyOpen)
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        open = true

        emit PoolOpen()
    }

    // Not that the owner could destroy the pool even when it is not full, not a big deal though.
    @using(assetsInContract = true, updateFields = false, checkExternalCaller = true)
    pub fn destroyPool() -> () {
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        destroySelf!(poolOwner)

        emit Destroy(poolOwner)
    }

    @using(assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn changeMinAmountToHold(newAmount: U256) -> () {
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        minTokenAmountToHold = newAmount

        emit NewMinTokenAmountToHold(newAmount)
    }


}
